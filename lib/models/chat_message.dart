import 'package:uuid/uuid.dart';

enum ChatMessageSender { user, ai }

// Define the type of input that generated the message
enum InputType { text, ocr, url, question, image, pdf, file } // Added pdf, file

class ChatMessage {
  final String id;
  final String text; // The actual full text content
  final ChatMessageSender sender;
  final DateTime timestamp;
  final bool isPlaceholderSummary; // For AI responses to OCR
  final String? displayOverride; // Transient field for UI override on load
  final InputType inputType; // Added: Store the original input type
  int? userRating; // Added: 1 for up, -1 for down, null for no rating
  final String? reportCategory;
  final String? reportComment;
  final List<String>? relatedConcepts; // ADDED: For related concepts

  ChatMessage({
    String? id,
    required this.text,
    required this.timestamp,
    required this.sender,
    this.displayOverride,
    this.isPlaceholderSummary = false, // Provide default value
    this.inputType = InputType.text, // Provide default value
    this.userRating,
    this.reportCategory,
    this.reportComment,
    this.relatedConcepts, // ADDED
  }) : id = id ?? const Uuid().v4();

  ChatMessage copyWith({
    String? id,
    String? text,
    DateTime? timestamp,
    ChatMessageSender? sender,
    String? displayOverride,
    bool clearDisplayOverride = false, // Special flag to nullify displayOverride
    bool? isPlaceholderSummary, // ADDED
    InputType? inputType, // ADDED
    int? userRating,
    bool clearUserRating = false, // Special flag to nullify userRating
    String? reportCategory,
    bool clearReportCategory = false,
    String? reportComment,
    bool clearReportComment = false,
    List<String>? relatedConcepts, // ADDED
    bool clearRelatedConcepts = false, // ADDED
  }) {
    return ChatMessage(
      id: id ?? this.id,
      text: text ?? this.text,
      timestamp: timestamp ?? this.timestamp,
      sender: sender ?? this.sender,
      displayOverride: clearDisplayOverride ? null : (displayOverride ?? this.displayOverride),
      isPlaceholderSummary: isPlaceholderSummary ?? this.isPlaceholderSummary, // ADDED
      inputType: inputType ?? this.inputType, // ADDED
      userRating: clearUserRating ? null : (userRating ?? this.userRating),
      reportCategory: clearReportCategory ? null : (reportCategory ?? this.reportCategory),
      reportComment: clearReportComment ? null : (reportComment ?? this.reportComment),
      relatedConcepts: clearRelatedConcepts ? null : (relatedConcepts ?? this.relatedConcepts), // ADDED
    );
  }

  // Converts a ChatMessage to a Map for Supabase insertion into 'chat_messages' table
  Map<String, dynamic> toJsonForDb(String sessionId, String userId) {
    // displayOverride is NOT saved to the database
    return {
      'session_id': sessionId,
      'user_id': userId, // The user who owns this session/message
      'sender': sender == ChatMessageSender.user ? 'user' : 'ai',
      'content': text,
      'timestamp': timestamp.toIso8601String(),
      'is_placeholder_summary': isPlaceholderSummary,
      'input_type': inputType.name, // Save enum name as string
      'related_concepts': relatedConcepts, // ADDED for saving to DB
      // The 'id' for the chat_messages table row will be auto-generated by Supabase (UUID)
    };
  }

  // Helper to convert string from DB back to enum
  static InputType inputTypeFromString(String? typeString) {
    if (typeString == null) return InputType.text;
    return InputType.values.firstWhere(
      (e) => e.name == typeString,
      orElse: () => InputType.text, // Default if unknown type from DB
    );
  }

  // Factory constructor for creating a ChatMessage from a map (e.g., from Firestore)
  factory ChatMessage.fromMap(Map<String, dynamic> map, String id) {
    return ChatMessage(
      id: id,
      text: map['text'] as String,
      timestamp: DateTime.parse(map['timestamp'] as String),
      sender: ChatMessageSender.values.firstWhere((e) => e.toString() == map['sender'] as String),
      displayOverride: map['display_override'] as String?,
      isPlaceholderSummary: map['is_placeholder_summary'] as bool? ?? false, // ADDED
      inputType: InputType.values.firstWhere( // ADDED
        (e) => e.name == (map['input_type'] as String?), 
        orElse: () => InputType.text // Default if not found or null
      ),
      userRating: map['user_rating'] as int?,
      reportCategory: map['report_category'] as String?,
      reportComment: map['report_comment'] as String?,
      relatedConcepts: map['related_concepts'] != null 
          ? List<String>.from(map['related_concepts'])
          : null, // ADDED
    );
  }

  // Method to convert a ChatMessage instance to a map (e.g., for Firestore)
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'text': text,
      'sender': sender.toString(),
      'timestamp': timestamp.toIso8601String(),
      'display_override': displayOverride,
      'is_placeholder_summary': isPlaceholderSummary, // ADDED
      'input_type': inputType.name, // ADDED
      'user_rating': userRating,
      'report_category': reportCategory,
      'report_comment': reportComment,
      'related_concepts': relatedConcepts, // ADDED
    };
  }

  // Optional: Add fromJson/toJson methods if you plan to serialize this model,
  // for example, when saving chat history to Supabase.
  // Map<String, dynamic> toJson() => {
  //   'id': id,
  //   'text': text,
  //   'sender': sender.toString(), // or sender.name in Dart 3
  //   'timestamp': timestamp.toIso8601String(),
  // };

  // factory ChatMessage.fromJson(Map<String, dynamic> json) => ChatMessage(
  //   id: json['id'],
  //   text: json['text'],
  //   sender: ChatMessageSender.values.firstWhere((e) => e.toString() == json['sender']),
  //   timestamp: DateTime.parse(json['timestamp']),
  // );
} 